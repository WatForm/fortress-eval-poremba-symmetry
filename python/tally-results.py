# form of data:
# filename, unsat, scope, version, time(seconds)

import csv

goals = ["unsat","sat"]



MAXTIME = 20 * 60 

#tex_location = "results/"
tex_location = "/Users/nday/Dropbox/uw-shared/2022-ieee-tse-joe/tables-plots/"

outlier_threshold = 0.8
show_outliers = False
# this is useful because sometimes multiple versions will timeout on the same file
show_timeouts = True
# tuple position for data read from csv
name = 0
result = 1
scope = 2
version = 3
time = 4
originalsorts = 5
newsorts = 6

numentries = 3


# map filename to average time for that version
v1 = {}
v2 = {}
v2si = {}
v2g = {}
v3 = {}
v3si = {}
scp = {}
original_sorts = {}
new_sorts = {}

# needed for scatterplot
mymax = 0

def getv(v):
    if v=='v1':
        return v1
    elif v=='v2':
        return v2
    elif v=='v3':
        return v3
    elif v=='v3si':
        return v3si
    elif v=='v2si':
        return v2si
    elif v=='v2g':
        return v2g
    else:
        print("unknown version! "+v)
        exit(1)

def getname(v):
    if v=='v1':
        return "Fortress"
    elif v=='v2':
        return v2
    elif v=='v3':
        return "Fortress+"
    elif v=='v3si':
        return "Fortress+SI"
    elif v=='v2si':
        return v2si
    elif v=='v2g':
        return v2g
    else:
        print("unknown version! "+v)
        exit(1)

def make_table(table_filename,a,b,a_time,b_time,num_a_faster,num_b_faster,num_cases,x):
    tabf = open(table_filename,"w")   
    tabf.write("% This file is auto-generated by tally-results.py\n\n")
    tabf.write("\\captionof{table}{")
    tabf.write(getname(a) + " vs. " + getname(b))
    tabf.write(" on "+str(num_cases))
    tabf.write(" " + g.upper() + " problems}\n")
    tabf.write("\\label{tab:"+g+str(x)+"}\n")
    tabf.write('\\begin{tabular}{|p{3cm}|r|r|r|}\n')
    tabf.write('\\hline  \n')
    tabf.write('& '+ getname(a) + " & "+getname(b) + ' & Ratio \\\\ \n')
    tabf.write("\\hline \\hline \n")
    tabf.write("Total time (seconds) & "+str(round(a_time)) + " & " + str(round(b_time)) + " & "+str(round(b_time/a_time,2))+"\\\\ \n")
    tabf.write("\\hline  \n")
    tabf.write("\\# problem wins & "+str(num_a_faster) + " & "+str(num_b_faster)+" & \\\\ \n")
    tabf.write("\\hline\n")
    tabf.write("\\end{tabular}\n")

# The next two functions are used when we want to
# see the plot by itself in a file
def plot_start_file():
    '''
    \\documentclass[11pt]{article}
    \\usepackage{tikz}
    \\usepackage{pgfplots}
    \\pgfplotsset{width=7.5cm,compat=1.12}
    \\usepgfplotslibrary{fillbetween}
    \\begin{document}
    '''

def plot_end_file():
    '''
    \\end{document}
    '''

def plot_start(plotf,xname,yname,xmax,ymax):
    plotf.write('''
    % This file is auto-generated by tally-results.py

    \\begin{tikzpicture}
    \\pgfplotsset{
       scale only axis,
    }

    \\begin{axis}[
      axis lines = middle,
      xmin=0,
      ymin=0,
      xmax='''+str(xmax)+''',
      ymax='''+str(ymax)+''',
      x label style={at={(axis description cs:0.5,-0.1)},anchor=north},
      y label style={at={(axis description cs:-0.11,.5)},rotate=90,anchor=south},
      xlabel=
    '''+xname+''',
      ylabel=
    '''+yname+''',
    ]
    \\addplot[only marks, mark=x]
    coordinates{ % plot 1 data set
    ''')

def plot_end(plotf):
    plotf.write('''
    }; \\label{plot_one}
    \\draw [blue,dashed] (rel axis cs:0,0) -- (rel axis cs:1,1);
    % plot 1 legend entry
    \\addlegendimage{/pgfplots/refstyle=plot_one}
    \\end{axis}
    \\end{tikzpicture}
    ''')
    plotf.close()

# args are: name of output file, two dictionaries
def make_scatterplot(a,b,g):
    global filelist,mymax
    file_name = tex_location+g+"-"+getname(a)+"-vs-"+getname(b) +"-plot.tex"
    plotf = open(file_name,"w")
    plot_start(plotf,getname(a).strip()+ " (seconds)",getname(b).strip()+ " (seconds)",MAXTIME,MAXTIME)
    av = getv(a)
    bv = getv(b)
    for f in filelist:
        if f in av.keys() and f in bv.keys():
            #if not(av[f] in [TIMEOUT,NO_NEW_SORTS] or bv[f] in[TIMEOUT,NO_NEW_SORTS]):
            plotf.write("("+str(av[f])+","+str(bv[f])+")\n")
    plot_end(plotf)

def compare_sorts():
    #plotf = open(goal+"-sorts.tex","w")
    #plot_start(plotf,"Percent time change","Percent sort change",100,50)
    ll = []
    for f in v3si.keys():
        v3si_time = float(v3si[f])
        v3_time = float(v3[f])
        # may be negative 
        percent_time_change = round(((v3si_time - v3_time)/v3_time) * 100,0)
        #print(f+": "+str(percent_change))
        sorts_added = int(new_sorts[f]) - int(original_sorts[f])
        percent_sort_change = round((sorts_added/int(original_sorts[f])) * 100, 0)
        ll.append([v3_time,v3si_time,percent_time_change,original_sorts[f],new_sorts[f], percent_sort_change])
    ll.sort(key = lambda x:x[0])
    for i in ll:
        print("%s, %s, %4.0f, %s, %s, %4.0f"%(i[0],i[1],i[2],i[3],i[4],i[5]))
        #plotf.write("("+str(percent_time_change)+","+str(percent_sort_change)+")\n")
    #plot_end(plotf)

# arguments are string names
def compare(aa,bb,g,x):

    # assumption: we want the faster one to be "b"
    # so we look for outliers where "b" is much slower than "a"

    global mymax
    # v1[file] = average time (seconds)v1[file/]
    # v2[file] = average time (seconds)
    # etc

    a = getv(aa)
    b = getv(bb)
    num_a_faster = 0
    num_b_faster = 0
    num_same_value = 0

    total_a_time = 0
    total_b_time = 0

    total_files = 0

    for f in filelist:
        if f in a.keys() and f in b.keys():
            # put this first so these don't get counted for the timeout and 
            # other tallies

            if a[f] < b[f] :
                num_a_faster += 1
                # find outliers
                if a[f]/b[f] < outlier_threshold and show_outliers:
                    print("Outlier: "+ f)
                    print("Scope: "+ str(scp[f]))
                    print(aa +" time:"+str(round(a[f],2)) )
                    print(bb +" time:"+str(round(b[f],2)) +"\n")
            elif b[f] < a[f]:
                num_b_faster += 1
            else:
                num_same_value +=1
            total_a_time += a[f]
            total_b_time += b[f]
            total_files += 1

    # command-line output
    print(inputfilename)
    an = getname(aa)
    bn = getname(bb)
    print("All files: " + str(len(filelist)))
    print("Num files in tally: "+str(total_files))
    print("Num files same time: "+str(num_same_value))
    print("Total "+an+" time for all files "+str(round(total_a_time,2)))
    print("Total "+bn+" time for all files "+ str(round(total_b_time,2)))
    print("total"+bn+"/total"+an+" "+str(round(total_b_time/total_a_time,2)))

    print("Number of files "+an+" faster "+str(num_a_faster))
    print("Number of files "+bn+" faster "+str(num_b_faster))

    # latex output   
    a_b_table_tex_name = g+"-"+an+"-vs-"+bn+"-table.tex"

    make_table(tex_location+a_b_table_tex_name, \
        "v1", \
        "v3", \
        total_a_time, \
        total_b_time, \
        num_a_faster, \
        num_b_faster, \
        total_files, \
        x)





# ---- main -----
for g in goals:
    data = []
    filelist = []
    inputfilename = "results/"+g+"-v1-v3-v3si-time-data.txt"

    with open(inputfilename) as f:
        reader = csv.reader(f,delimiter=",")
        for row in reader:
            fname = row[0].strip()
            if not (fname in filelist):
                filelist.append(fname)
            if row[version].strip() != "v3si":
                data.append([fname,row[result].strip(),row[scope].strip(),row[version].strip(),row[time].strip()])
            else:
                data.append([fname,row[result].strip(),row[scope].strip(),row[version].strip(),row[time].strip(),row[originalsorts].strip(),row[newsorts].strip()])

    for f in filelist:
        # get all the rows in the results file for this test
        f_entries = [r for r in data if r[0] == f]

        # all entries should be for this scope
        sc = f_entries[0][scope]
        scp[f] = sc

        # sanitization checks    
        for j in f_entries:
            if j[scope] != sc or j[result]!=g:
                # data checks: all were run for same scope and got the expected result
                print(sc)
                print(j[scope])
                print(g)
                print(j[result])
                print("check "+j[0]+" scopes or results don't match")
                exit(1)

        # take the average of the entries for each version
        # and store it in the dictionary

        # this is per file
        for v in ['v1','v3','v3si']:
            f_v_entries = [r for r in f_entries if r[version] == v]
            if f_v_entries!=[]:
                if len(f_v_entries)!=numentries:
                    print("check "+f+" not "+str(numentries)+" data entries for "+v)
                    exit(1)
                sum = 0
                for i in f_v_entries:
                    sum += float(i[time])
                getv(v)[f] = round(sum/numentries,2)
                if v == 'v3si':
                    # sorts found will all be the same
                    # could check this
                    #print(f_v_entries)
                    original_sorts[f] = f_v_entries[0][originalsorts]
                    new_sorts[f] = f_v_entries[0][newsorts]



    print('-----')
    print('Compare Fortress with Fortress+ for '+g+'\n')
    compare("v1","v3",g,1)

    print("")

    print('-----')
    print('Compare Fortress+ with Fortress+SI for '+g+'\n')
    compare("v3","v3si",g,2)

    make_scatterplot("v1","v3",g)
    make_scatterplot("v3", "v3si",g)


    # used to look at sort data
    # compare_sorts()

